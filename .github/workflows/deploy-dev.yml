name: Deploy to Development

on:
  push:
    branches: [develop]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if checks fail'
        required: false
        type: boolean
        default: false

concurrency:
  group: deploy-dev
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE_NAME: ${{ github.repository }}/backend
  FRONTEND_IMAGE_NAME: ${{ github.repository }}/frontend
  DEPLOYMENT_TIMEOUT: 600

jobs:
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.decision.outputs.should_deploy }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Check CI status
        id: ci_check
        uses: actions/github-script@v7
        with:
          script: |
            const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ci.yml',
              branch: 'develop',
              status: 'completed',
              per_page: 1
            });

            const latestRun = runs.workflow_runs[0];
            const ciPassed = latestRun && latestRun.conclusion === 'success';

            core.setOutput('ci_passed', ciPassed);
            core.info(`Latest CI run: ${latestRun?.conclusion || 'not found'}`);
            return ciPassed;

      - name: Check build status
        id: build_check
        uses: actions/github-script@v7
        with:
          script: |
            const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'build.yml',
              branch: 'develop',
              status: 'completed',
              per_page: 1
            });

            const latestRun = runs.workflow_runs[0];
            const buildPassed = latestRun && latestRun.conclusion === 'success';

            core.setOutput('build_passed', buildPassed);
            core.info(`Latest build run: ${latestRun?.conclusion || 'not found'}`);
            return buildPassed;

      - name: Make deployment decision
        id: decision
        run: |
          CI_PASSED="${{ steps.ci_check.outputs.ci_passed }}"
          BUILD_PASSED="${{ steps.build_check.outputs.build_passed }}"
          FORCE_DEPLOY="${{ github.event.inputs.force_deploy }}"

          if [[ "$FORCE_DEPLOY" == "true" ]]; then
            echo "Force deploy requested, proceeding..."
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "$CI_PASSED" == "true" && "$BUILD_PASSED" == "true" ]]; then
            echo "All checks passed, proceeding with deployment"
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "Pre-deployment checks failed. CI: $CI_PASSED, Build: $BUILD_PASSED"
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  deploy:
    name: Deploy to Development Environment
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true'
    environment:
      name: development
      url: https://dev.resume-app.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull latest images
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:develop
          docker pull ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:develop

      - name: Create deployment environment file
        run: |
          cat > .env.deploy << EOF
          DATABASE_URL=${{ secrets.DEV_DATABASE_URL }}
          REDIS_URL=${{ secrets.DEV_REDIS_URL }}
          SECRET_KEY=${{ secrets.DEV_SECRET_KEY }}
          ENVIRONMENT=development
          DEBUG=False
          LOG_LEVEL=INFO
          CORS_ORIGINS=${{ secrets.DEV_CORS_ORIGINS }}
          BACKEND_IMAGE=${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:develop
          FRONTEND_IMAGE=${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:develop
          EOF

      - name: Run database migrations
        run: |
          docker run --rm \
            --env-file .env.deploy \
            ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:develop \
            alembic upgrade head

      - name: Deploy with Docker Compose
        run: |
          export $(cat .env.deploy | xargs)
          docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d
        timeout-minutes: 10

      - name: Wait for services to be ready
        run: |
          echo "Waiting for backend service..."
          timeout ${{ env.DEPLOYMENT_TIMEOUT }} bash -c '
            until curl -f -s http://localhost:8000/ready > /dev/null; do
              echo "Backend not ready, waiting..."
              sleep 5
            done
          '

          echo "Waiting for frontend service..."
          timeout ${{ env.DEPLOYMENT_TIMEOUT }} bash -c '
            until curl -f -s http://localhost:80/health > /dev/null; do
              echo "Frontend not ready, waiting..."
              sleep 5
            done
          '

          echo "All services are ready"

      - name: Run health checks
        id: health_check
        run: |
          echo "Checking backend health..."
          BACKEND_HEALTH=$(curl -s http://localhost:8000/health | jq -r '.status')

          echo "Checking backend readiness..."
          BACKEND_READY=$(curl -s http://localhost:8000/ready | jq -r '.status')

          echo "Checking frontend health..."
          FRONTEND_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:80/health)

          echo "Backend Health: $BACKEND_HEALTH"
          echo "Backend Ready: $BACKEND_READY"
          echo "Frontend Health: $FRONTEND_HEALTH"

          if [[ "$BACKEND_HEALTH" != "healthy" ]] || [[ "$BACKEND_READY" != "ready" ]] || [[ "$FRONTEND_HEALTH" != "200" ]]; then
            echo "Health checks failed"
            exit 1
          fi

          echo "All health checks passed"

      - name: Run smoke tests
        run: |
          echo "Running smoke tests..."

          # Test backend API endpoints
          curl -f http://localhost:8000/health
          curl -f http://localhost:8000/ready

          # Test frontend
          curl -f http://localhost:80/
          curl -f http://localhost:80/health

          echo "Smoke tests passed"

      - name: Capture deployment logs
        if: always()
        run: |
          mkdir -p deployment-logs
          docker-compose logs --tail=500 backend > deployment-logs/backend.log
          docker-compose logs --tail=500 frontend > deployment-logs/frontend.log
          docker-compose logs --tail=500 db > deployment-logs/db.log
          docker-compose logs --tail=500 redis > deployment-logs/redis.log

      - name: Upload deployment logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs-${{ github.run_number }}
          path: deployment-logs/
          retention-days: 7

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed, initiating rollback..."

          # Stop current deployment
          docker-compose down

          # Pull and deploy previous stable version
          docker pull ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:stable
          docker pull ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:stable

          # Update environment to use stable images
          sed -i 's/:develop/:stable/g' .env.deploy

          # Redeploy with stable images
          export $(cat .env.deploy | xargs)
          docker-compose -f docker-compose.yml -f docker-compose.dev.yml up -d

          echo "Rollback completed"

      - name: Tag successful deployment as stable
        if: success()
        run: |
          docker tag ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:develop \
                     ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:stable
          docker tag ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:develop \
                     ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:stable

          docker push ${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:stable
          docker push ${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:stable

  post-deployment:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: deploy
    if: always()

    steps:
      - name: Notify deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ needs.deploy.result }}';
            const emoji = status === 'success' ? '✅' : '❌';
            const message = `${emoji} Development deployment ${status}`;

            core.notice(message);

            // Create deployment status
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 0,
              state: status === 'success' ? 'success' : 'failure',
              description: message,
              environment: 'development'
            });

      - name: Generate deployment summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Development" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ needs.deploy.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY

      - name: Fail workflow if deployment failed
        if: needs.deploy.result == 'failure'
        run: exit 1
